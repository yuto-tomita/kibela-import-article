import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Represents non-fractional signed whole numeric values. Since the value may
   * exceed the size of a 32-bit integer, it's encoded as a string.
   */
  BigInt: any;
  Blob: any;
  /** A datetime type, encoded in ISO 8601 string in JSON, or timestamp type in MessagePack */
  DateTime: any;
};

/** Personal access tokens */
export type AccessToken = Node & {
  __typename?: 'AccessToken';
  createdAt: Scalars['DateTime'];
  description: Scalars['String'];
  descriptionHtml: Scalars['String'];
  id: Scalars['ID'];
  /** It returns true if (1) the access token is not revoked, and (2) the author of the access token is alive. */
  isActive: Scalars['Boolean'];
  isRevoked: Scalars['Boolean'];
  lastUsedAt?: Maybe<Scalars['DateTime']>;
  logs: AccessTokenLogConnection;
  path: Scalars['String'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String'];
  /** The secret token value, which is only available via `createAccessToken` mutation. */
  token?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  /** The author of the access token */
  user: User;
};


/** Personal access tokens */
export type AccessTokenLogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for AccessToken. */
export type AccessTokenConnection = {
  __typename?: 'AccessTokenConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>;
  /** A list of nodes. */
  nodes: Array<AccessToken>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AccessTokenEdge = {
  __typename?: 'AccessTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessToken>;
};

/** Usage logs for personal access tokens */
export type AccessTokenLog = Node & {
  __typename?: 'AccessTokenLog';
  accessToken: AccessToken;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  ipAddress: Scalars['String'];
  operationType: Scalars['String'];
  query: Scalars['String'];
  user: User;
  userAgent: Scalars['String'];
};

/** The connection type for AccessTokenLog. */
export type AccessTokenLogConnection = {
  __typename?: 'AccessTokenLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenLogEdge>>>;
  /** A list of nodes. */
  nodes: Array<AccessTokenLog>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AccessTokenLogEdge = {
  __typename?: 'AccessTokenLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessTokenLog>;
};

export enum AccessTokenScope {
  /** @deprecated Not yet implemented */
  Administer = 'ADMINISTER',
  Read = 'READ',
  Write = 'WRITE'
}

/** Autogenerated input type of ArchiveFolder */
export type ArchiveFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of ArchiveFolder */
export type ArchiveFolderPayload = {
  __typename?: 'ArchiveFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
};

/** Autogenerated input type of ArchiveGroup */
export type ArchiveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
};

/** Autogenerated return type of ArchiveGroup */
export type ArchiveGroupPayload = {
  __typename?: 'ArchiveGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of ArchiveNote */
export type ArchiveNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of ArchiveNote */
export type ArchiveNotePayload = {
  __typename?: 'ArchiveNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of AttachNoteToFolder */
export type AttachNoteToFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  folder: FolderInput;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of AttachNoteToFolder */
export type AttachNoteToFolderPayload = {
  __typename?: 'AttachNoteToFolderPayload';
  attachedFolder: Folder;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
  note: Note;
};

export type Attachment = Node & {
  __typename?: 'Attachment';
  author: User;
  createdAt: Scalars['DateTime'];
  /** The data of the attachment in binary. Prefer `data_url` if you use JSON for serializers */
  data: Scalars['Blob'];
  /** The same value as `data` but encoded in data URL schema */
  dataUrl: Scalars['String'];
  id: Scalars['ID'];
  key: Scalars['String'];
  kind: AttachmentKind;
  /** A MIME type detected from its data and name */
  mimeType: Scalars['String'];
  name: Scalars['String'];
  path: Scalars['String'];
  /** The file size */
  size: Scalars['Int'];
  url: Scalars['String'];
};

/** How and where the attachment is used. */
export enum AttachmentKind {
  General = 'GENERAL',
  GroupCoverImage = 'GROUP_COVER_IMAGE',
  UserAvatarImage = 'USER_AVATAR_IMAGE',
  UserCoverImage = 'USER_COVER_IMAGE'
}

/** Kibela Web API budget like RateLimit of RESTful API */
export type Budget = {
  __typename?: 'Budget';
  consumed: Scalars['BigInt'];
  /** The point cost for the current query counting against the budget. */
  cost: Scalars['BigInt'];
  remaining: Scalars['BigInt'];
};

/** Autogenerated input type of CloseAnnouncement */
export type CloseAnnouncementInput = {
  announcementKey: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CloseAnnouncement */
export type CloseAnnouncementPayload = {
  __typename?: 'CloseAnnouncementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A comment that belongs to a Note */
export type Comment = Node & {
  __typename?: 'Comment';
  anchor: Scalars['String'];
  author: User;
  canBeLiked: Scalars['Boolean'];
  canBeUpdated: Scalars['Boolean'];
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  contentSummaryHtml: Scalars['String'];
  contentUpdatedAt: Scalars['DateTime'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime'];
  editedAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  isEdited: Scalars['Boolean'];
  isLikedByCurrentUser: Scalars['Boolean'];
  likers: UserConnection;
  path: Scalars['String'];
  publishedAt?: Maybe<Scalars['DateTime']>;
  replies: CommentReplyConnection;
  updatedAt: Scalars['DateTime'];
};


/** A comment that belongs to a Note */
export type CommentContributorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** A comment that belongs to a Note */
export type CommentLikersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A comment that belongs to a Note */
export type CommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  nodes: Array<Comment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** The Comment Reply type */
export type CommentReply = Node & {
  __typename?: 'CommentReply';
  anchor: Scalars['String'];
  author: User;
  canBeLiked: Scalars['Boolean'];
  canBeUpdated: Scalars['Boolean'];
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  contentSummaryHtml: Scalars['String'];
  contentUpdatedAt: Scalars['DateTime'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime'];
  editedAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  isEdited: Scalars['Boolean'];
  isLikedByCurrentUser: Scalars['Boolean'];
  likers: UserConnection;
  path: Scalars['String'];
  publishedAt?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
};


/** The Comment Reply type */
export type CommentReplyContributorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** The Comment Reply type */
export type CommentReplyLikersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CommentReply. */
export type CommentReplyConnection = {
  __typename?: 'CommentReplyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentReplyEdge>>>;
  /** A list of nodes. */
  nodes: Array<CommentReply>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CommentReplyEdge = {
  __typename?: 'CommentReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CommentReply>;
};

export type ContributorOrder = {
  direction?: InputMaybe<OrderDirection>;
  field?: InputMaybe<ContributorOrderField>;
};

/** Properties by which contributors can be ordered. */
export enum ContributorOrderField {
  ContributedAt = 'CONTRIBUTED_AT'
}

/** Autogenerated input type of CreateAccessToken */
export type CreateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String'];
};

/** Autogenerated return type of CreateAccessToken */
export type CreateAccessTokenPayload = {
  __typename?: 'CreateAccessTokenPayload';
  /** It includes the secret `token`, which you never see again. */
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateComment */
export type CreateCommentInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  commentableId: Scalars['ID'];
  content: Scalars['String'];
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
};

/** Autogenerated return type of CreateComment */
export type CreateCommentPayload = {
  __typename?: 'CreateCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  comment: Comment;
};

/** Autogenerated input type of CreateCommentReply */
export type CreateCommentReplyInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  commentId: Scalars['ID'];
  content: Scalars['String'];
  /** The time when the comment is published. If not specified, `createdAt` is set to `publishedAt` */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
};

/** Autogenerated return type of CreateCommentReply */
export type CreateCommentReplyPayload = {
  __typename?: 'CreateCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  reply: CommentReply;
};

/** Autogenerated input type of CreateCustomEmoji */
export type CreateCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Up to 50 alphanumeric characters and underscores(_) can be used. */
  emojiCode: Scalars['String'];
  /** BASE64 encoded image data URL */
  imageDataUrl: Scalars['String'];
};

/** Autogenerated return type of CreateCustomEmoji */
export type CreateCustomEmojiPayload = {
  __typename?: 'CreateCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  customEmoji: CustomEmoji;
};

/** Autogenerated input type of CreateDisabledUser */
export type CreateDisabledUserInput = {
  /** `account` must be unique in the team */
  account: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** `email` must be unique in the team */
  email: Scalars['String'];
  realName: Scalars['String'];
  role?: InputMaybe<Role>;
};

/** Autogenerated return type of CreateDisabledUser */
export type CreateDisabledUserPayload = {
  __typename?: 'CreateDisabledUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  user: User;
};

/** Autogenerated input type of CreateFolder */
export type CreateFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  folder?: InputMaybe<FolderInput>;
  folderName?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateFolder */
export type CreateFolderPayload = {
  __typename?: 'CreateFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
};

/** Autogenerated input type of CreateFolderPin */
export type CreateFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Target folder. It is required when the note has 2 or more associated folders. */
  folder?: InputMaybe<FolderInput>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of CreateFolderPin */
export type CreateFolderPinPayload = {
  __typename?: 'CreateFolderPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
};

/** Autogenerated input type of CreateGroup */
export type CreateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  coverImageKey?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  isPrivate: Scalars['Boolean'];
  name: Scalars['String'];
};

/** Autogenerated return type of CreateGroup */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of CreateGroupPin */
export type CreateGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
  noteId: Scalars['ID'];
};

/** Autogenerated return type of CreateGroupPin */
export type CreateGroupPinPayload = {
  __typename?: 'CreateGroupPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of CreateNote */
export type CreateNoteInput = {
  /**
   * You can set any user as the author.
   * The default is the user who executes this mutation.
   * Note that the contributors still include the user who executes this mutation in order to avoid spoofing.
   */
  authorId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  coediting: Scalars['Boolean'];
  content: Scalars['String'];
  draft?: InputMaybe<Scalars['Boolean']>;
  folderName?: InputMaybe<Scalars['String']>;
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']>;
  /** The time when the note is published. If `draft: true` is specified, the param is ignored. */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  title: Scalars['String'];
};

/** Autogenerated return type of CreateNote */
export type CreateNotePayload = {
  __typename?: 'CreateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of CreateNoteTemplate */
export type CreateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  coediting: Scalars['Boolean'];
  content: Scalars['String'];
  folderFullName?: InputMaybe<Scalars['String']>;
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']>;
  name: Scalars['String'];
  title: Scalars['String'];
};

/** Autogenerated return type of CreateNoteTemplate */
export type CreateNoteTemplatePayload = {
  __typename?: 'CreateNoteTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of CreateReviewableDraftComment */
export type CreateReviewableDraftCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  reviewableDraftId: Scalars['ID'];
};

/** Autogenerated return type of CreateReviewableDraftComment */
export type CreateReviewableDraftCommentPayload = {
  __typename?: 'CreateReviewableDraftCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  comment: ReviewableDraftComment;
};

/** The Custom Emoji type */
export type CustomEmoji = Node & {
  __typename?: 'CustomEmoji';
  createUser: User;
  createdAt: Scalars['DateTime'];
  emojiCode: Scalars['String'];
  id: Scalars['ID'];
  imageUrl: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

/** The connection type for CustomEmoji. */
export type CustomEmojiConnection = {
  __typename?: 'CustomEmojiConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomEmojiEdge>>>;
  /** A list of nodes. */
  nodes: Array<CustomEmoji>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CustomEmojiEdge = {
  __typename?: 'CustomEmojiEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CustomEmoji>;
};

/** A dashboard of a group */
export type Dashboard = Node & {
  __typename?: 'Dashboard';
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  createdAt: Scalars['DateTime'];
  group: Group;
  id: Scalars['ID'];
  updatedAt: Scalars['DateTime'];
};

/** Autogenerated input type of DeleteAttachment */
export type DeleteAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteAttachment */
export type DeleteAttachmentPayload = {
  __typename?: 'DeleteAttachmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteComment */
export type DeleteCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteComment */
export type DeleteCommentPayload = {
  __typename?: 'DeleteCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCommentReply */
export type DeleteCommentReplyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteCommentReply */
export type DeleteCommentReplyPayload = {
  __typename?: 'DeleteCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteCustomEmoji */
export type DeleteCustomEmojiInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  customEmojiId: Scalars['ID'];
};

/** Autogenerated return type of DeleteCustomEmoji */
export type DeleteCustomEmojiPayload = {
  __typename?: 'DeleteCustomEmojiPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteGroup */
export type DeleteGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  mergeToId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of DeleteGroup */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteNote */
export type DeleteNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteNote */
export type DeleteNotePayload = {
  __typename?: 'DeleteNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DetachNoteFromFolder */
export type DetachNoteFromFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  folder: FolderInput;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of DetachNoteFromFolder */
export type DetachNoteFromFolderPayload = {
  __typename?: 'DetachNoteFromFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  detachedFolder: Folder;
  note: Note;
};

/** Autogenerated input type of DisableDraftReview */
export type DisableDraftReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of DisableDraftReview */
export type DisableDraftReviewPayload = {
  __typename?: 'DisableDraftReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of DisableOutgoingWebhook */
export type DisableOutgoingWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DisableOutgoingWebhook */
export type DisableOutgoingWebhookPayload = {
  __typename?: 'DisableOutgoingWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of DisableSharedNotesFeature */
export type DisableSharedNotesFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DisableSharedNotesFeature */
export type DisableSharedNotesFeaturePayload = {
  __typename?: 'DisableSharedNotesFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DisableUser */
export type DisableUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DisableUser */
export type DisableUserPayload = {
  __typename?: 'DisableUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of EnableDraftReview */
export type EnableDraftReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of EnableDraftReview */
export type EnableDraftReviewPayload = {
  __typename?: 'EnableDraftReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  reviewableDraft: ReviewableDraft;
};

/** Autogenerated input type of EnableOutgoingWebhook */
export type EnableOutgoingWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of EnableOutgoingWebhook */
export type EnableOutgoingWebhookPayload = {
  __typename?: 'EnableOutgoingWebhookPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  outgoingWebhook: OutgoingWebhook;
};

/** Autogenerated input type of EnableSharedNotesFeature */
export type EnableSharedNotesFeatureInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of EnableSharedNotesFeature */
export type EnableSharedNotesFeaturePayload = {
  __typename?: 'EnableSharedNotesFeaturePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcel = {
  __typename?: 'FeedFolderParcel';
  date: Scalars['DateTime'];
  folder: Folder;
  notes: NoteConnection;
};


/** A section of a feed, which includes notes in a folder */
export type FeedFolderParcelNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The kind to indicate what the feed is */
export enum FeedKind {
  All = 'ALL',
  Group = 'GROUP',
  MyFeed = 'MY_FEED'
}

/** A section of feed, which includes a note */
export type FeedNote = {
  __typename?: 'FeedNote';
  date: Scalars['DateTime'];
  note: Note;
};

/** A section of feed, which includes one or more notes */
export type FeedSection = FeedFolderParcel | FeedNote | FeedUserParcel;

export type FeedSectionSimpleConnection = {
  __typename?: 'FeedSectionSimpleConnection';
  edges: Array<FeedSectionSimpleEdge>;
  pageInfo: FeedSectionSimplePageInfo;
};

export type FeedSectionSimpleEdge = {
  __typename?: 'FeedSectionSimpleEdge';
  node: FeedSection;
};

export type FeedSectionSimplePageInfo = {
  __typename?: 'FeedSectionSimplePageInfo';
  endCursor: Scalars['String'];
};

/** A section of feed, which includes notes written by a user */
export type FeedUserParcel = {
  __typename?: 'FeedUserParcel';
  date: Scalars['DateTime'];
  notes: NoteConnection;
  user: User;
};


/** A section of feed, which includes notes written by a user */
export type FeedUserParcelNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type Folder = Node & {
  __typename?: 'Folder';
  archivedAt?: Maybe<Scalars['DateTime']>;
  components: Array<Folder>;
  createdAt: Scalars['DateTime'];
  folders: FolderConnection;
  fullName: Scalars['String'];
  group: Group;
  id: Scalars['ID'];
  lastModifiedAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  newNotePath: Scalars['String'];
  notes: NoteConnection;
  parent?: Maybe<Folder>;
  path: Scalars['String'];
  pinnedNotes: NoteConnection;
  updatedAt: Scalars['DateTime'];
};


export type FolderFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type FolderNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyCoediting?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<NoteOrder>;
};


export type FolderPinnedNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Folder. */
export type FolderConnection = {
  __typename?: 'FolderConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FolderEdge>>>;
  /** A list of nodes. */
  nodes: Array<Folder>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type FolderEdge = {
  __typename?: 'FolderEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Folder>;
};

/** Input folder with group struct */
export type FolderInput = {
  folderName: Scalars['String'];
  groupId: Scalars['ID'];
};

export type Group = Node & {
  __typename?: 'Group';
  archivedAt?: Maybe<Scalars['DateTime']>;
  /** @deprecated deleteGroup will be removed. Use archiveGroup instead. */
  canBeDestroyed: Scalars['Boolean'];
  canBeManaged: Scalars['Boolean'];
  coverImage: GroupCoverImage;
  coverImageKey?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars['Int'];
  description: Scalars['String'];
  /** @deprecated Use query.feedSections instead */
  feedSections: FeedSectionSimpleConnection;
  feedUpdatedAt?: Maybe<Scalars['DateTime']>;
  folders: FolderConnection;
  id: Scalars['ID'];
  isArchived: Scalars['Boolean'];
  isDefault: Scalars['Boolean'];
  isJoined: Scalars['Boolean'];
  isPrivate: Scalars['Boolean'];
  isVisibilityChangeable: Scalars['Boolean'];
  name: Scalars['String'];
  notes: NoteConnection;
  path: Scalars['String'];
  pinnedNotes: Array<Note>;
  todayContributors: UserConnection;
  trendNotes: NoteConnection;
  updatedAt: Scalars['DateTime'];
  users: UserConnection;
};


export type GroupCoverImageArgs = {
  density: Scalars['Int'];
  size: GroupCoverImageSize;
};


export type GroupFeedSectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
};


export type GroupFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  parentFolderId?: InputMaybe<Scalars['ID']>;
  parentFolderIds?: InputMaybe<Array<Scalars['ID']>>;
  withChildren?: InputMaybe<Scalars['Boolean']>;
};


export type GroupNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyNotAttachedFolder?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<NoteOrder>;
};


export type GroupTodayContributorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupTrendNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type GroupUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Abilities for groups. */
export enum GroupAbility {
  AssociationManageable = 'ASSOCIATION_MANAGEABLE',
  Readable = 'READABLE'
}

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes: Array<Group>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** Cover image of a group */
export type GroupCoverImage = {
  __typename?: 'GroupCoverImage';
  density: Scalars['Int'];
  height: Scalars['Int'];
  url: Scalars['String'];
  width: Scalars['Int'];
};

/** The size class of group cover images */
export enum GroupCoverImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM'
}

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

/** Autogenerated input type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  userId: Scalars['ID'];
};

/** Autogenerated return type of IgnoreMultiFactorAuthn */
export type IgnoreMultiFactorAuthnPayload = {
  __typename?: 'IgnoreMultiFactorAuthnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A user representation from importable services */
export type ImportableUser = {
  __typename?: 'ImportableUser';
  account: Scalars['String'];
  avatarUrl: Scalars['String'];
  realName: Scalars['String'];
};

/** The connection type for ImportableUser. */
export type ImportableUserConnection = {
  __typename?: 'ImportableUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ImportableUserEdge>>>;
  /** A list of nodes. */
  nodes: Array<ImportableUser>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ImportableUserEdge = {
  __typename?: 'ImportableUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ImportableUser>;
};

/** Message hints that suggest what happens in sending invitations */
export enum InvitationHint {
  /** They is already a member of the team. Nothing is done. */
  AlreadyJoined = 'ALREADY_JOINED',
  /** The invitation has been sent to them. */
  Invited = 'INVITED',
  /** Those who is disabled before is now re-enabled. Nothing is done. */
  ReEnabled = 'RE_ENABLED'
}

/** Autogenerated input type of Invite */
export type InviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  role?: InputMaybe<Role>;
};

/** Autogenerated return type of Invite */
export type InvitePayload = {
  __typename?: 'InvitePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  hint: InvitationHint;
  role: Role;
};

/** Autogenerated input type of JoinGroup */
export type JoinGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
  userId: Scalars['ID'];
};

/** Autogenerated return type of JoinGroup */
export type JoinGroupPayload = {
  __typename?: 'JoinGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of LeaveGroup */
export type LeaveGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
  userId: Scalars['ID'];
};

/** Autogenerated return type of LeaveGroup */
export type LeaveGroupPayload = {
  __typename?: 'LeaveGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of Like */
export type LikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  likableId: Scalars['ID'];
};

/** Autogenerated return type of Like */
export type LikePayload = {
  __typename?: 'LikePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  likers: UserConnection;
};


/** Autogenerated return type of Like */
export type LikePayloadLikersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of MarkNotificationsAsRead */
export type MarkNotificationsAsReadPayload = {
  __typename?: 'MarkNotificationsAsReadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MoveNoteToAnotherFolder */
export type MoveNoteToAnotherFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  fromFolder: FolderInput;
  noteId: Scalars['ID'];
  toFolder: FolderInput;
};

/** Autogenerated return type of MoveNoteToAnotherFolder */
export type MoveNoteToAnotherFolderPayload = {
  __typename?: 'MoveNoteToAnotherFolderPayload';
  afterFolder: Folder;
  beforeFolder: Folder;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
  note: Note;
};

/** Autogenerated input type of MoveNoteToAnotherGroup */
export type MoveNoteToAnotherGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  fromGroupId: Scalars['ID'];
  noteId: Scalars['ID'];
  toGroupId: Scalars['ID'];
};

/** Autogenerated return type of MoveNoteToAnotherGroup */
export type MoveNoteToAnotherGroupPayload = {
  __typename?: 'MoveNoteToAnotherGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** The top-level mutation type to mutate resources */
export type Mutation = {
  __typename?: 'Mutation';
  /** Archive a folder */
  archiveFolder?: Maybe<ArchiveFolderPayload>;
  /** Archive a group */
  archiveGroup?: Maybe<ArchiveGroupPayload>;
  /** Archive a note */
  archiveNote?: Maybe<ArchiveNotePayload>;
  /** Attach a note to folder */
  attachNoteToFolder?: Maybe<AttachNoteToFolderPayload>;
  /** Close an announcement */
  closeAnnouncement?: Maybe<CloseAnnouncementPayload>;
  /** It creates an access token */
  createAccessToken?: Maybe<CreateAccessTokenPayload>;
  /** Creates a comment */
  createComment?: Maybe<CreateCommentPayload>;
  /** Creates a reply to the comment */
  createCommentReply?: Maybe<CreateCommentReplyPayload>;
  /** Creates a custom emoji */
  createCustomEmoji?: Maybe<CreateCustomEmojiPayload>;
  /** It creates a disabled user with the specified profile. It requires  **administrative privileges**. */
  createDisabledUser?: Maybe<CreateDisabledUserPayload>;
  /** Creates a folder */
  createFolder?: Maybe<CreateFolderPayload>;
  /** Pin note to a folder */
  createFolderPin?: Maybe<CreateFolderPinPayload>;
  /**
   * Creates a group. The current user is added as a group member.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new group.
   */
  createGroup?: Maybe<CreateGroupPayload>;
  /** Pin note to a group */
  createGroupPin?: Maybe<CreateGroupPinPayload>;
  /** Creates a note */
  createNote?: Maybe<CreateNotePayload>;
  /** Create a note template */
  createNoteTemplate?: Maybe<CreateNoteTemplatePayload>;
  /** Creates a draft review comment */
  createReviewableDraftComment?: Maybe<CreateReviewableDraftCommentPayload>;
  /** It deletes an attachment that is owned by the current user. */
  deleteAttachment?: Maybe<DeleteAttachmentPayload>;
  /** Deletes a comment */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes a reply to comment */
  deleteCommentReply?: Maybe<DeleteCommentReplyPayload>;
  /** Deletes a custom emoji */
  deleteCustomEmoji?: Maybe<DeleteCustomEmojiPayload>;
  /**
   * Delete a group
   * @deprecated This feature will be deleted. Use archiveGroup mutation instead.
   */
  deleteGroup?: Maybe<DeleteGroupPayload>;
  /** Deletes a note */
  deleteNote?: Maybe<DeleteNotePayload>;
  /** Detach a note from folder */
  detachNoteFromFolder?: Maybe<DetachNoteFromFolderPayload>;
  /** Disable draft review of the specified note. */
  disableDraftReview?: Maybe<DisableDraftReviewPayload>;
  /** Disable Outgoing Webhook */
  disableOutgoingWebhook?: Maybe<DisableOutgoingWebhookPayload>;
  /**
   * Disable shared notes feature in the team settings
   * @deprecated This feature was renamed to disableSharedNotesFeature mutation and will be removed.
   *
   */
  disableSharedEntry?: Maybe<DisableSharedNotesFeaturePayload>;
  /** Disable shared notes feature in the team settings */
  disableSharedNotesFeature?: Maybe<DisableSharedNotesFeaturePayload>;
  /** Disables a user. The current user must be an *admin* or *owner*. */
  disableUser?: Maybe<DisableUserPayload>;
  /** Enable draft review of the specified note. */
  enableDraftReview?: Maybe<EnableDraftReviewPayload>;
  /** Enable Outgoing Webhook */
  enableOutgoingWebhook?: Maybe<EnableOutgoingWebhookPayload>;
  /**
   * Enable shared notes feature in the team settings
   * @deprecated This feature was renamed to enableSharedNotesFeature mutation and will be removed.
   *
   */
  enableSharedEntry?: Maybe<EnableSharedNotesFeaturePayload>;
  /** Enable shared notes feature in the team settings */
  enableSharedNotesFeature?: Maybe<EnableSharedNotesFeaturePayload>;
  /** Ignore multi factor authn for 1 day. */
  ignoreMultiFactorAuthn?: Maybe<IgnoreMultiFactorAuthnPayload>;
  /**
   * Invites a user with their email.
   * Only owners and admins can invite users.
   *
   * It may fail with the `UPGRADE_REQUIRED` error code if the plan is free and there is no room to create a new user.
   */
  invite?: Maybe<InvitePayload>;
  /** Join a group */
  joinGroup?: Maybe<JoinGroupPayload>;
  /** Leave a group */
  leaveGroup?: Maybe<LeaveGroupPayload>;
  /** Like a note or comment */
  like?: Maybe<LikePayload>;
  markNotificationsAsRead?: Maybe<MarkNotificationsAsReadPayload>;
  /** Move a note to another folder */
  moveNoteToAnotherFolder?: Maybe<MoveNoteToAnotherFolderPayload>;
  /** Move a note to another group */
  moveNoteToAnotherGroup?: Maybe<MoveNoteToAnotherGroupPayload>;
  /** Remove pinned note from a folder */
  removeFolderPin?: Maybe<RemoveFolderPinPayload>;
  /** Remove pinned note from a group */
  removeGroupPin?: Maybe<RemoveGroupPinPayload>;
  /** Restore an archived folder */
  restoreFolder?: Maybe<RestoreFolderPayload>;
  /** Restore an archived group */
  restoreGroup?: Maybe<RestoreGroupPayload>;
  /** Restore an archived note */
  restoreNote?: Maybe<RestoreNotePayload>;
  /** It revokes an access token; the secret `token` is available after the access token is revoked. */
  revokeAccessToken?: Maybe<RevokeAccessTokenPayload>;
  /** Share specified note with outside of the team */
  shareNoteWithOutsideOfTeam?: Maybe<ShareNoteWithOutsideOfTeamPayload>;
  /** Transfer notes of a group to another */
  transferGroupNotes?: Maybe<TransferGroupNotesPayload>;
  /** Unlike a note or comment */
  unlike?: Maybe<UnlikePayload>;
  /** Unshare specified note with outside of the team */
  unshareNoteWithOutsideOfTeam?: Maybe<UnshareNoteWithOutsideOfTeamPayload>;
  /** Unwatch a note */
  unwatchNote?: Maybe<UnwatchNotePayload>;
  /** It updates attributes of an access token */
  updateAccessToken?: Maybe<UpdateAccessTokenPayload>;
  /** Updates a comment */
  updateComment?: Maybe<UpdateCommentPayload>;
  /** Updates a reply to comment */
  updateCommentReply?: Maybe<UpdateCommentReplyPayload>;
  /** Update the content of dashboard without conflict-checking. Use updateDashboardContent to check conflict. */
  updateDashboard?: Maybe<UpdateDashboardPayload>;
  /** Update the content of a dashboard with simple conflict-checking */
  updateDashboardContent?: Maybe<UpdateDashboardContentPayload>;
  /** Update name of a folder */
  updateFolderName?: Maybe<UpdateFolderNamePayload>;
  /** Update the folder parent */
  updateFolderParent?: Maybe<UpdateFolderParentPayload>;
  /** Update a group */
  updateGroup?: Maybe<UpdateGroupPayload>;
  /** Update a note, trying to merge conflicts with the 3-way diff algorithm */
  updateNote?: Maybe<UpdateNotePayload>;
  /** Update the content of a note with conflict-checking, trying 3-way merging on conflicts */
  updateNoteContent?: Maybe<UpdateNoteContentPayload>;
  /**
   * Update a folder associated to a note.
   * This mutation works only with the following cases, which are self-evident. If not, it returns an error.
   * 1. If folder_full_name is not null and the note has no folders and the note
   * has only one group, then add the folder with the group.
   * 2. If folder_full_name is not null and the note has only one folder, then update the folder with the given name.
   * 3. If folder_full_name is null and the note has only one folder, then remove the folder from the note.
   * 4. if folder_full_name is null and the note has no folders, then nothing to do.
   * @deprecated This feature will be deleted. Use attachNoteToFolder, moveNoteToAnotherFolder and detachNoteFromFolder mutations instead.
   */
  updateNoteFolder?: Maybe<UpdateNoteFolderPayload>;
  /** Update a note template */
  updateNoteTemplate?: Maybe<UpdateNoteTemplatePayload>;
  /** Update title of a note */
  updateNoteTitle?: Maybe<UpdateNoteTitlePayload>;
  /** Update team setting */
  updateTeamSetting?: Maybe<UpdateTeamSettingPayload>;
  /** Update notification setting of current user */
  updateUserNotificationSetting?: Maybe<UpdateUserNotificationSettingPayload>;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachment?: Maybe<UploadAttachmentPayload>;
  /** Upload an attachment as files in markdown contents, avatars, or cover images. */
  uploadAttachmentWithDataUrl?: Maybe<UploadAttachmentWithDataUrlPayload>;
  /** Watch a note */
  watchNote?: Maybe<WatchNotePayload>;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveFolderArgs = {
  input: ArchiveFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveGroupArgs = {
  input: ArchiveGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationArchiveNoteArgs = {
  input: ArchiveNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationAttachNoteToFolderArgs = {
  input: AttachNoteToFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCloseAnnouncementArgs = {
  input: CloseAnnouncementInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateAccessTokenArgs = {
  input: CreateAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCommentReplyArgs = {
  input: CreateCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateCustomEmojiArgs = {
  input: CreateCustomEmojiInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateDisabledUserArgs = {
  input: CreateDisabledUserInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateFolderArgs = {
  input: CreateFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateFolderPinArgs = {
  input: CreateFolderPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateGroupPinArgs = {
  input: CreateGroupPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateNoteArgs = {
  input: CreateNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateNoteTemplateArgs = {
  input: CreateNoteTemplateInput;
};


/** The top-level mutation type to mutate resources */
export type MutationCreateReviewableDraftCommentArgs = {
  input: CreateReviewableDraftCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteAttachmentArgs = {
  input: DeleteAttachmentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCommentReplyArgs = {
  input: DeleteCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteCustomEmojiArgs = {
  input: DeleteCustomEmojiInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDeleteNoteArgs = {
  input: DeleteNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDetachNoteFromFolderArgs = {
  input: DetachNoteFromFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableDraftReviewArgs = {
  input: DisableDraftReviewInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableOutgoingWebhookArgs = {
  input: DisableOutgoingWebhookInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableSharedEntryArgs = {
  input: DisableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableSharedNotesFeatureArgs = {
  input: DisableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationDisableUserArgs = {
  input: DisableUserInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableDraftReviewArgs = {
  input: EnableDraftReviewInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableOutgoingWebhookArgs = {
  input: EnableOutgoingWebhookInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableSharedEntryArgs = {
  input: EnableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationEnableSharedNotesFeatureArgs = {
  input: EnableSharedNotesFeatureInput;
};


/** The top-level mutation type to mutate resources */
export type MutationIgnoreMultiFactorAuthnArgs = {
  input: IgnoreMultiFactorAuthnInput;
};


/** The top-level mutation type to mutate resources */
export type MutationInviteArgs = {
  input: InviteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationJoinGroupArgs = {
  input: JoinGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationLeaveGroupArgs = {
  input: LeaveGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationLikeArgs = {
  input: LikeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsReadInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMoveNoteToAnotherFolderArgs = {
  input: MoveNoteToAnotherFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationMoveNoteToAnotherGroupArgs = {
  input: MoveNoteToAnotherGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRemoveFolderPinArgs = {
  input: RemoveFolderPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRemoveGroupPinArgs = {
  input: RemoveGroupPinInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreFolderArgs = {
  input: RestoreFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreGroupArgs = {
  input: RestoreGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRestoreNoteArgs = {
  input: RestoreNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationRevokeAccessTokenArgs = {
  input: RevokeAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationShareNoteWithOutsideOfTeamArgs = {
  input: ShareNoteWithOutsideOfTeamInput;
};


/** The top-level mutation type to mutate resources */
export type MutationTransferGroupNotesArgs = {
  input: TransferGroupNotesInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnlikeArgs = {
  input: UnlikeInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnshareNoteWithOutsideOfTeamArgs = {
  input: UnshareNoteWithOutsideOfTeamInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUnwatchNoteArgs = {
  input: UnwatchNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateAccessTokenArgs = {
  input: UpdateAccessTokenInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentArgs = {
  input: UpdateCommentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateCommentReplyArgs = {
  input: UpdateCommentReplyInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardArgs = {
  input: UpdateDashboardInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateDashboardContentArgs = {
  input: UpdateDashboardContentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderNameArgs = {
  input: UpdateFolderNameInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateFolderParentArgs = {
  input: UpdateFolderParentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteArgs = {
  input: UpdateNoteInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteContentArgs = {
  input: UpdateNoteContentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteFolderArgs = {
  input: UpdateNoteFolderInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTemplateArgs = {
  input: UpdateNoteTemplateInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateNoteTitleArgs = {
  input: UpdateNoteTitleInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateTeamSettingArgs = {
  input: UpdateTeamSettingInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUpdateUserNotificationSettingArgs = {
  input: UpdateUserNotificationSettingInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentArgs = {
  input: UploadAttachmentInput;
};


/** The top-level mutation type to mutate resources */
export type MutationUploadAttachmentWithDataUrlArgs = {
  input: UploadAttachmentWithDataUrlInput;
};


/** The top-level mutation type to mutate resources */
export type MutationWatchNoteArgs = {
  input: WatchNoteInput;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** The Note type */
export type Note = Node & {
  __typename?: 'Note';
  author?: Maybe<User>;
  canBeCommented: Scalars['Boolean'];
  canBeDestroyed: Scalars['Boolean'];
  canBeLiked: Scalars['Boolean'];
  canBeUpdated: Scalars['Boolean'];
  coediting: Scalars['Boolean'];
  comments: CommentConnection;
  commentsCount: Scalars['Int'];
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  contentSummaryHtml: Scalars['String'];
  contentTocHtml: Scalars['String'];
  contentUpdatedAt: Scalars['DateTime'];
  contributors: UserConnection;
  createdAt: Scalars['DateTime'];
  /** @deprecated Provided only for legacy frontend. */
  databaseId: Scalars['Int'];
  editPath: Scalars['String'];
  /** @deprecated Note can now have multiple folders, use folders. */
  folder?: Maybe<Folder>;
  /** @deprecated Note can now have multiple folders, use folders. */
  folderName?: Maybe<Scalars['String']>;
  folders?: Maybe<FolderConnection>;
  groups: Array<Group>;
  id: Scalars['ID'];
  isArchived: Scalars['Boolean'];
  isLikedByCurrentUser: Scalars['Boolean'];
  likers: UserConnection;
  path: Scalars['String'];
  publishedAt?: Maybe<Scalars['DateTime']>;
  relatedNotes: SearchResultConnection;
  reviewableDraft?: Maybe<ReviewableDraft>;
  sharedNote?: Maybe<SharedNote>;
  title: Scalars['String'];
  /** @deprecated There is ExtendedText component in js, so almost unnecessary to use it */
  titleHtml: Scalars['String'];
  trackbackNotes: NoteConnection;
  updatedAt: Scalars['DateTime'];
  url: Scalars['String'];
};


/** The Note type */
export type NoteCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Note type */
export type NoteContributorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ContributorOrder>;
};


/** The Note type */
export type NoteFoldersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Note type */
export type NoteLikersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Note type */
export type NoteRelatedNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Note type */
export type NoteTrackbackNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Browsing history of notes */
export type NoteBrowsingHistory = Node & {
  __typename?: 'NoteBrowsingHistory';
  id: Scalars['ID'];
  note?: Maybe<Note>;
};

/** The connection type for NoteBrowsingHistory. */
export type NoteBrowsingHistoryConnection = {
  __typename?: 'NoteBrowsingHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteBrowsingHistoryEdge>>>;
  /** A list of nodes. */
  nodes: Array<NoteBrowsingHistory>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NoteBrowsingHistoryEdge = {
  __typename?: 'NoteBrowsingHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NoteBrowsingHistory>;
};

/** The connection type for Note. */
export type NoteConnection = {
  __typename?: 'NoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteEdge>>>;
  /** A list of nodes. */
  nodes: Array<Note>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NoteEdge = {
  __typename?: 'NoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Note>;
};

/** Note input struct, used to updateNote mutation */
export type NoteInput = {
  coediting: Scalars['Boolean'];
  content: Scalars['String'];
  folderName?: InputMaybe<Scalars['String']>;
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']>;
  title: Scalars['String'];
};

export type NoteOrder = {
  direction?: InputMaybe<OrderDirection>;
  field?: InputMaybe<NoteOrderField>;
};

/** Properties by which notes can be ordered. */
export enum NoteOrderField {
  ContentUpdatedAt = 'CONTENT_UPDATED_AT',
  PublishedAt = 'PUBLISHED_AT',
  Title = 'TITLE'
}

/** Template of note */
export type NoteTemplate = Node & {
  __typename?: 'NoteTemplate';
  content: Scalars['String'];
  createdAt: Scalars['DateTime'];
  evaluatedTitle: Scalars['String'];
  /** @deprecated NoteTemplate can now have multiple folders, use folders. This field now always returns null. */
  folderEvaluatedFullName?: Maybe<Scalars['String']>;
  /** @deprecated NoteTemplate can now have multiple folders, use folders. This field now always returns null. */
  folderFullName?: Maybe<Scalars['String']>;
  folders: Array<NoteTemplateFolder>;
  groups: Array<Group>;
  id: Scalars['ID'];
  name: Scalars['String'];
  title: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

/** The connection type for NoteTemplate. */
export type NoteTemplateConnection = {
  __typename?: 'NoteTemplateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NoteTemplateEdge>>>;
  /** A list of nodes. */
  nodes: Array<NoteTemplate>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NoteTemplateEdge = {
  __typename?: 'NoteTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<NoteTemplate>;
};

/** Folder for note template. */
export type NoteTemplateFolder = Node & {
  __typename?: 'NoteTemplateFolder';
  createdAt: Scalars['DateTime'];
  evaluatedFullName?: Maybe<Scalars['String']>;
  fullName: Scalars['String'];
  group: Group;
  id: Scalars['ID'];
  updatedAt: Scalars['DateTime'];
};

/** Notifications you get in a Kibela team */
export type Notification = Node & {
  __typename?: 'Notification';
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  messageHtml: Scalars['String'];
  sender: User;
  sourcePath: Scalars['String'];
  state: NotificationState;
  updatedAt: Scalars['DateTime'];
};

/** The connection type for Notification. */
export type NotificationConnection = {
  __typename?: 'NotificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** A list of nodes. */
  nodes: Array<Notification>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

/** The state of notifications */
export enum NotificationState {
  Read = 'READ',
  Unread = 'UNREAD'
}

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** Kind of the organization */
export enum OrganizationKind {
  Company = 'COMPANY',
  Other = 'OTHER',
  Personal = 'PERSONAL',
  Unknown = 'UNKNOWN'
}

/** A outgoing_webhook */
export type OutgoingWebhook = Node & {
  __typename?: 'OutgoingWebhook';
  disabledAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** The top-level query type to Kibela resources */
export type Query = {
  __typename?: 'Query';
  accessToken: AccessToken;
  accessTokens: AccessTokenConnection;
  /** The archived groups in the team including private ones */
  archivedGroups: GroupConnection;
  attachmentFromPath: Attachment;
  budget: Budget;
  /** @deprecated This is beta and internal feature. */
  coeditToken: Scalars['String'];
  comment?: Maybe<Comment>;
  /** The current user of the session */
  currentUser?: Maybe<User>;
  customEmojiFromCode: CustomEmoji;
  customEmojis: CustomEmojiConnection;
  /** @deprecated This is an internal feature. */
  customEmojisCacheKey: Scalars['String'];
  defaultGroup?: Maybe<Group>;
  feedSections: FeedSectionSimpleConnection;
  folder?: Maybe<Folder>;
  /**
   * Returns all folders.
   * Note that the field does not distinguish groups.
   * If you need to fetch folders that is related a specific group, use GroupType.folders field.
   */
  folders: FolderConnection;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
  group: Group;
  /** The active groups in the team. */
  groups: GroupConnection;
  importableUsers: ImportableUserConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>;
  note?: Maybe<Note>;
  noteBrowsingHistories: NoteBrowsingHistoryConnection;
  /** @deprecated Use noteBrowsingHistories instead. */
  noteBrowsingHistries: NoteBrowsingHistoryConnection;
  noteFromPath: Note;
  noteTemplate?: Maybe<NoteTemplate>;
  noteTemplates: NoteTemplateConnection;
  /** The connection of all the notes in the team. You *should* specify `orderBy` in production. */
  notes: NoteConnection;
  notifications?: Maybe<NotificationConnection>;
  renderMarkdownToHtml: Scalars['String'];
  reviewableDraft?: Maybe<ReviewableDraft>;
  search: SearchResultConnection;
  sharedNote: SharedNote;
  /** All the shared notes in the team. */
  sharedNotes: SharedNoteConnection;
  /** All the access token logs in the team. This feature requires the administrative privileges */
  teamAccessTokenLogs: AccessTokenLogConnection;
  user?: Maybe<User>;
  userFromAccount?: Maybe<User>;
  users: UserConnection;
  /** @deprecated This is internal feature. */
  validateToMove: Scalars['Boolean'];
};


/** The top-level query type to Kibela resources */
export type QueryAccessTokenArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  revoked?: InputMaybe<Scalars['Boolean']>;
};


/** The top-level query type to Kibela resources */
export type QueryArchivedGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryAttachmentFromPathArgs = {
  path: Scalars['String'];
};


/** The top-level query type to Kibela resources */
export type QueryCoeditTokenArgs = {
  noteId: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryCommentArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryCustomEmojiFromCodeArgs = {
  code: Scalars['String'];
};


/** The top-level query type to Kibela resources */
export type QueryCustomEmojisArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryFeedSectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  first: Scalars['Int'];
  groupId?: InputMaybe<Scalars['ID']>;
  kind?: InputMaybe<FeedKind>;
};


/** The top-level query type to Kibela resources */
export type QueryFolderArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryFoldersArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  parentFolderId?: InputMaybe<Scalars['ID']>;
  parentFolderIds?: InputMaybe<Array<Scalars['ID']>>;
};


/** The top-level query type to Kibela resources */
export type QueryGroupArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryGroupsArgs = {
  ability?: InputMaybe<GroupAbility>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryImportableUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  encryptedAccessToken: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  page: Scalars['Int'];
  serviceType: Scalars['String'];
  teamName: Scalars['String'];
};


/** The top-level query type to Kibela resources */
export type QueryNodeArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


/** The top-level query type to Kibela resources */
export type QueryNoteArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteBrowsingHistoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryNoteBrowsingHistriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryNoteFromPathArgs = {
  path: Scalars['String'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteTemplateArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryNoteTemplatesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryNotesArgs = {
  active?: InputMaybe<Scalars['Boolean']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  folderId?: InputMaybe<Scalars['ID']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NoteOrder>;
};


/** The top-level query type to Kibela resources */
export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<NotificationState>;
};


/** The top-level query type to Kibela resources */
export type QueryRenderMarkdownToHtmlArgs = {
  content: Scalars['String'];
  isMain: Scalars['Boolean'];
};


/** The top-level query type to Kibela resources */
export type QueryReviewableDraftArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QuerySearchArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  coediting?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  folderIds?: InputMaybe<Array<Scalars['ID']>>;
  groupIds?: InputMaybe<Array<Scalars['ID']>>;
  isArchived?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  query: Scalars['String'];
  updated?: InputMaybe<SearchDate>;
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};


/** The top-level query type to Kibela resources */
export type QuerySharedNoteArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QuerySharedNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryTeamAccessTokenLogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The top-level query type to Kibela resources */
export type QueryUserArgs = {
  id: Scalars['ID'];
};


/** The top-level query type to Kibela resources */
export type QueryUserFromAccountArgs = {
  account: Scalars['String'];
};


/** The top-level query type to Kibela resources */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  confirmed?: InputMaybe<Scalars['Boolean']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  groupId?: InputMaybe<Scalars['ID']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** The top-level query type to Kibela resources */
export type QueryValidateToMoveArgs = {
  folderIds: Array<Scalars['ID']>;
  noteIds?: InputMaybe<Array<Scalars['ID']>>;
  parentId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated input type of RemoveFolderPin */
export type RemoveFolderPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Target folder. It is required when the note has 2 or more associated folders. */
  folder?: InputMaybe<FolderInput>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of RemoveFolderPin */
export type RemoveFolderPinPayload = {
  __typename?: 'RemoveFolderPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
};

/** Autogenerated input type of RemoveGroupPin */
export type RemoveGroupPinInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
  noteId: Scalars['ID'];
};

/** Autogenerated return type of RemoveGroupPin */
export type RemoveGroupPinPayload = {
  __typename?: 'RemoveGroupPinPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of RestoreFolder */
export type RestoreFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of RestoreFolder */
export type RestoreFolderPayload = {
  __typename?: 'RestoreFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
};

/** Autogenerated input type of RestoreGroup */
export type RestoreGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
};

/** Autogenerated return type of RestoreGroup */
export type RestoreGroupPayload = {
  __typename?: 'RestoreGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of RestoreNote */
export type RestoreNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of RestoreNote */
export type RestoreNotePayload = {
  __typename?: 'RestoreNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** The Reviewable Draft type */
export type ReviewableDraft = {
  __typename?: 'ReviewableDraft';
  comments: ReviewableDraftCommentConnection;
  id: Scalars['ID'];
  isEnabled: Scalars['Boolean'];
  url: Scalars['String'];
};


/** The Reviewable Draft type */
export type ReviewableDraftCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A comment that belongs to a reviewable drarft */
export type ReviewableDraftComment = Node & {
  __typename?: 'ReviewableDraftComment';
  anchor: Scalars['String'];
  author: User;
  content: Scalars['String'];
  contentHtml: Scalars['String'];
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  path: Scalars['String'];
};

/** The connection type for ReviewableDraftComment. */
export type ReviewableDraftCommentConnection = {
  __typename?: 'ReviewableDraftCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewableDraftCommentEdge>>>;
  /** A list of nodes. */
  nodes: Array<ReviewableDraftComment>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReviewableDraftCommentEdge = {
  __typename?: 'ReviewableDraftCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewableDraftComment>;
};

/** Autogenerated input type of RevokeAccessToken */
export type RevokeAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** AccessToken ID */
  id: Scalars['ID'];
};

/** Autogenerated return type of RevokeAccessToken */
export type RevokeAccessTokenPayload = {
  __typename?: 'RevokeAccessTokenPayload';
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A role of a user */
export enum Role {
  Admin = 'ADMIN',
  FullMember = 'FULL_MEMBER',
  Guest = 'GUEST',
  Owner = 'OWNER'
}

export enum SearchDate {
  Within_1Month = 'WITHIN_1_MONTH',
  Within_1Week = 'WITHIN_1_WEEK',
  Within_1Year = 'WITHIN_1_YEAR',
  Within_3Days = 'WITHIN_3_DAYS',
  Within_6Months = 'WITHIN_6_MONTHS'
}

/** A search result that refers to a document */
export type SearchResult = {
  __typename?: 'SearchResult';
  author: User;
  contentSummaryHtml: Scalars['String'];
  contentUpdatedAt: Scalars['DateTime'];
  /** The original searchable document */
  document: SearchableDocument;
  /** @deprecated Note can now have multiple folders, use folders field in document field on Note. */
  folder?: Maybe<Folder>;
  path: Scalars['String'];
  title: Scalars['String'];
  titleHtml: Scalars['String'];
  url: Scalars['String'];
};

/** The connection type for SearchResult. */
export type SearchResultConnection = {
  __typename?: 'SearchResultConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchResultEdge>>>;
  /** A list of nodes. */
  nodes: Array<SearchResult>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SearchResultEdge = {
  __typename?: 'SearchResultEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SearchResult>;
};

export type SearchableDocument = Comment | CommentReply | Note;

/** Autogenerated input type of ShareNoteWithOutsideOfTeam */
export type ShareNoteWithOutsideOfTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of ShareNoteWithOutsideOfTeam */
export type ShareNoteWithOutsideOfTeamPayload = {
  __typename?: 'ShareNoteWithOutsideOfTeamPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** The Shared Note type */
export type SharedNote = Node & {
  __typename?: 'SharedNote';
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  note: Note;
  totalPageviews: Scalars['Int'];
  url: Scalars['String'];
};

/** The connection type for SharedNote. */
export type SharedNoteConnection = {
  __typename?: 'SharedNoteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SharedNoteEdge>>>;
  /** A list of nodes. */
  nodes: Array<SharedNote>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SharedNoteEdge = {
  __typename?: 'SharedNoteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SharedNote>;
};

/** Autogenerated input type of TransferGroupNotes */
export type TransferGroupNotesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  fromGroupId: Scalars['ID'];
  toGroupId: Scalars['ID'];
};

/** Autogenerated return type of TransferGroupNotes */
export type TransferGroupNotesPayload = {
  __typename?: 'TransferGroupNotesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  from: Group;
  to: Group;
};

/** Autogenerated input type of Unlike */
export type UnlikeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  likableId: Scalars['ID'];
};

/** Autogenerated return type of Unlike */
export type UnlikePayload = {
  __typename?: 'UnlikePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  likers: UserConnection;
};


/** Autogenerated return type of Unlike */
export type UnlikePayloadLikersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of UnshareNoteWithOutsideOfTeam */
export type UnshareNoteWithOutsideOfTeamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of UnshareNoteWithOutsideOfTeam */
export type UnshareNoteWithOutsideOfTeamPayload = {
  __typename?: 'UnshareNoteWithOutsideOfTeamPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of UnwatchNote */
export type UnwatchNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of UnwatchNote */
export type UnwatchNotePayload = {
  __typename?: 'UnwatchNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateAccessToken */
export type UpdateAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  id: Scalars['ID'];
  scopes: Array<AccessTokenScope>;
  title: Scalars['String'];
};

/** Autogenerated return type of UpdateAccessToken */
export type UpdateAccessTokenPayload = {
  __typename?: 'UpdateAccessTokenPayload';
  accessToken: AccessToken;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateComment */
export type UpdateCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  id: Scalars['ID'];
  touch?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateComment */
export type UpdateCommentPayload = {
  __typename?: 'UpdateCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  comment: Comment;
};

/** Autogenerated input type of UpdateCommentReply */
export type UpdateCommentReplyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  id: Scalars['ID'];
  touch?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateCommentReply */
export type UpdateCommentReplyPayload = {
  __typename?: 'UpdateCommentReplyPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  reply: CommentReply;
};

/** Autogenerated input type of UpdateDashboardContent */
export type UpdateDashboardContentInput = {
  baseContent: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A group ID for the dashboard */
  groupId: Scalars['ID'];
  newContent: Scalars['String'];
};

/** Autogenerated return type of UpdateDashboardContent */
export type UpdateDashboardContentPayload = {
  __typename?: 'UpdateDashboardContentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateDashboard */
export type UpdateDashboardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  content: Scalars['String'];
  groupId: Scalars['ID'];
};

/** Autogenerated return type of UpdateDashboard */
export type UpdateDashboardPayload = {
  __typename?: 'UpdateDashboardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  dashboard: Dashboard;
};

/** Autogenerated input type of UpdateFolderName */
export type UpdateFolderNameInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  name: Scalars['String'];
};

/** Autogenerated return type of UpdateFolderName */
export type UpdateFolderNamePayload = {
  __typename?: 'UpdateFolderNamePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
};

/** Autogenerated input type of UpdateFolderParent */
export type UpdateFolderParentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** New parent folder path (ex. aaa/bbb) */
  folderFullName?: InputMaybe<Scalars['String']>;
  /** Target folder id */
  folderId: Scalars['ID'];
};

/** Autogenerated return type of UpdateFolderParent */
export type UpdateFolderParentPayload = {
  __typename?: 'UpdateFolderParentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  folder: Folder;
  /** @deprecated This is an internal feature. */
  foldersCacheKey: Scalars['String'];
};

/** Autogenerated input type of UpdateGroup */
export type UpdateGroupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  coverImageKey?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateGroup */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  group: Group;
};

/** Autogenerated input type of UpdateNoteContent */
export type UpdateNoteContentInput = {
  baseContent: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  newContent: Scalars['String'];
  /** If false, content_updated_at is not touched. */
  touch?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateNoteContent */
export type UpdateNoteContentPayload = {
  __typename?: 'UpdateNoteContentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteFolder */
export type UpdateNoteFolderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  folderFullName?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
};

/** Autogenerated return type of UpdateNoteFolder */
export type UpdateNoteFolderPayload = {
  __typename?: 'UpdateNoteFolderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of UpdateNote */
export type UpdateNoteInput = {
  baseNote: NoteInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  draft: Scalars['Boolean'];
  id: Scalars['ID'];
  newNote: NoteInput;
  /** It will be truncated to 100 characters if exceeded. */
  noteEditMemo?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateNote */
export type UpdateNotePayload = {
  __typename?: 'UpdateNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of UpdateNoteTemplate */
export type UpdateNoteTemplateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  coediting: Scalars['Boolean'];
  content: Scalars['String'];
  folderFullName?: InputMaybe<Scalars['String']>;
  folders?: InputMaybe<Array<FolderInput>>;
  groupIds: Array<Scalars['ID']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  title: Scalars['String'];
};

/** Autogenerated return type of UpdateNoteTemplate */
export type UpdateNoteTemplatePayload = {
  __typename?: 'UpdateNoteTemplatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  noteTemplate: NoteTemplate;
};

/** Autogenerated input type of UpdateNoteTitle */
export type UpdateNoteTitleInput = {
  baseTitle: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  newTitle: Scalars['String'];
};

/** Autogenerated return type of UpdateNoteTitle */
export type UpdateNoteTitlePayload = {
  __typename?: 'UpdateNoteTitlePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  note: Note;
};

/** Autogenerated input type of UpdateTeamSetting */
export type UpdateTeamSettingInput = {
  city?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  departmentName?: InputMaybe<Scalars['String']>;
  inChargeUserId?: InputMaybe<Scalars['ID']>;
  organizationKind?: InputMaybe<OrganizationKind>;
  organizationName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  postalCode?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  streetAddress?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateTeamSetting */
export type UpdateTeamSettingPayload = {
  __typename?: 'UpdateTeamSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateUserNotificationSetting */
export type UpdateUserNotificationSettingInput = {
  checked: Scalars['Boolean'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  kind: UserNotificationSettingKind;
};

/** Autogenerated return type of UpdateUserNotificationSetting */
export type UpdateUserNotificationSettingPayload = {
  __typename?: 'UpdateUserNotificationSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UploadAttachment */
export type UploadAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  data: Scalars['Blob'];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** The name of attachment, typically a filename. */
  name: Scalars['String'];
};

/** Autogenerated return type of UploadAttachment */
export type UploadAttachmentPayload = {
  __typename?: 'UploadAttachmentPayload';
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The data which encoded in Data URL scheme defined in RFC 2397 */
  dataUrl: Scalars['String'];
  /** It indicates how and where the attachment is used. */
  kind: AttachmentKind;
  /** The name of attachment, typically a filename. */
  name: Scalars['String'];
};

/** Autogenerated return type of UploadAttachmentWithDataUrl */
export type UploadAttachmentWithDataUrlPayload = {
  __typename?: 'UploadAttachmentWithDataUrlPayload';
  attachment: Attachment;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** A user, which is an individual account of a team */
export type User = Node & {
  __typename?: 'User';
  account?: Maybe<Scalars['String']>;
  /** @deprecated Use avatarImage instead */
  avatar: UserAvatarImage;
  avatarImage: UserAvatarImage;
  biography?: Maybe<Scalars['String']>;
  coverImage?: Maybe<UserCoverImage>;
  /** `email` requires administrative privileges because it is a kind of personal data. */
  email: Scalars['String'];
  groups?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  latestNotes: NoteConnection;
  locale: Scalars['String'];
  path?: Maybe<Scalars['String']>;
  popularNotes: NoteConnection;
  privateNotes: NoteConnection;
  realName?: Maybe<Scalars['String']>;
  role: Role;
  shortBio?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
};


/** A user, which is an individual account of a team */
export type UserAvatarArgs = {
  density?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<UserAvatarImageSize>;
};


/** A user, which is an individual account of a team */
export type UserAvatarImageArgs = {
  density?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<UserAvatarImageSize>;
};


/** A user, which is an individual account of a team */
export type UserCoverImageArgs = {
  density?: InputMaybe<Scalars['Int']>;
  size?: InputMaybe<UserCoverImageSize>;
};


/** A user, which is an individual account of a team */
export type UserGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user, which is an individual account of a team */
export type UserLatestNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user, which is an individual account of a team */
export type UserPopularNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user, which is an individual account of a team */
export type UserPrivateNotesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An avatar image of users */
export type UserAvatarImage = {
  __typename?: 'UserAvatarImage';
  density: Scalars['Int'];
  height: Scalars['Int'];
  url: Scalars['String'];
  width: Scalars['Int'];
};

/** The size class of user avatar images */
export enum UserAvatarImageSize {
  Large = 'LARGE',
  Medium = 'MEDIUM',
  Small = 'SMALL'
}

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes: Array<User>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  totalCount: Scalars['Int'];
};

/** A cover image of users */
export type UserCoverImage = {
  __typename?: 'UserCoverImage';
  density: Scalars['Int'];
  height: Scalars['Int'];
  key: Scalars['String'];
  size: UserCoverImageSize;
  url: Scalars['String'];
  width: Scalars['Int'];
};

/** The size class of user cover images */
export enum UserCoverImageSize {
  Medium = 'MEDIUM',
  Original = 'ORIGINAL',
  Small = 'SMALL'
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** The kind of user notification settings */
export enum UserNotificationSettingKind {
  NewsletterMail = 'NEWSLETTER_MAIL'
}

/** Autogenerated input type of WatchNote */
export type WatchNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  noteId: Scalars['ID'];
  /** note_update or comment. */
  watchedAction: WatchState;
};

/** Autogenerated return type of WatchNote */
export type WatchNotePayload = {
  __typename?: 'WatchNotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** State of watching note */
export enum WatchState {
  WatchComment = 'WATCH_COMMENT',
  WatchNoteUpdate = 'WATCH_NOTE_UPDATE'
}

export type FetchKibelaArticleContentQueryQueryVariables = Exact<{
  first: Scalars['Int'];
}>;


export type FetchKibelaArticleContentQueryQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', latestNotes: { __typename?: 'NoteConnection', nodes: Array<{ __typename?: 'Note', title: string, contentHtml: string }> } } | null };

export type FetchPostNumberQueryVariables = Exact<{
  first: Scalars['Int'];
}>;


export type FetchPostNumberQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', latestNotes: { __typename?: 'NoteConnection', totalCount: number } } | null };

export type FetchFirstKibelaArticleContentQueryQueryVariables = Exact<{
  first: Scalars['Int'];
}>;


export type FetchFirstKibelaArticleContentQueryQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', latestNotes: { __typename?: 'NoteConnection', nodes: Array<{ __typename?: 'Note', title: string, contentHtml: string }> } } | null };


export const FetchKibelaArticleContentQueryDocument = gql`
    query fetchKibelaArticleContentQuery($first: Int!) {
  currentUser {
    latestNotes(first: $first) {
      nodes {
        title
        contentHtml
      }
    }
  }
}
    `;
export const FetchPostNumberDocument = gql`
    query fetchPostNumber($first: Int!) {
  currentUser {
    latestNotes(first: $first) {
      totalCount
    }
  }
}
    `;
export const FetchFirstKibelaArticleContentQueryDocument = gql`
    query fetchFirstKibelaArticleContentQuery($first: Int!) {
  currentUser {
    latestNotes(first: 1) {
      nodes {
        title
        contentHtml
      }
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    fetchKibelaArticleContentQuery(variables: FetchKibelaArticleContentQueryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<FetchKibelaArticleContentQueryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<FetchKibelaArticleContentQueryQuery>(FetchKibelaArticleContentQueryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'fetchKibelaArticleContentQuery', 'query');
    },
    fetchPostNumber(variables: FetchPostNumberQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<FetchPostNumberQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<FetchPostNumberQuery>(FetchPostNumberDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'fetchPostNumber', 'query');
    },
    fetchFirstKibelaArticleContentQuery(variables: FetchFirstKibelaArticleContentQueryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<FetchFirstKibelaArticleContentQueryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<FetchFirstKibelaArticleContentQueryQuery>(FetchFirstKibelaArticleContentQueryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'fetchFirstKibelaArticleContentQuery', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;